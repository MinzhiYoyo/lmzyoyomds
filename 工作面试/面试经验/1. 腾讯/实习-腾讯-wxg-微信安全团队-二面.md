

***注意：***回答是我自己的回答，不保正确。

***注意：***回答是我自己的回答，不保正确。

***注意：***回答是我自己的回答，不保正确。

# 前言

上来就是手撕，先给了四道，然后发现有一道没写好，又给了一道，也有可能是我没开视频，然后有点怀疑我作弊吧，后面就要我开视频了。哎，以后长记性了，还是得全程开视频的……



面试流程是，上来就是手撕，然后八股拷打

# 项目拷打

问：连接池，有没有从`sql`往上写

问：平时有写过`sql`吗

问：计算机设计大赛是什么类别的

# 八股拷打

问：多线程用过吗？多线程是有单独的栈的，这个栈是在内存空间哪的

问：函数里的内存是在栈里面分配的，为什么多线程是在堆里分配的呢

问：`Linux`上面文件操作有吗？打开文件的系统调用过程是怎么样的？

问：16GB的内存，怎么读32GB的问题，可以成功吗？并且是一次性全读入

问：一个文件传输，应用层和TCP层是怎么交互的

问：文件很大，通过TCP传输，能用一个TCP包传输吗？有哪些限制

问：`write`系统调用的返回值是什么含义

问：刚调用`write`完就断电或断网，会发生什么，实际上发送成功没？

问：有没有用过协程？协程具体作用是什么

问：协程跨线程调度是为什么要这么做？比如`go`里面的协程就可以跨线程，自己思考一下







# 手撕

好像手撕基本上都是讲讲思路，没有说一定要通过实例啥的。

## 题目1

```
有一个大于等于0的数字N，其最大值为10^100000，现在定义两个操作：
问最少多少次可以把这个数变成0

输入用例1
7
输出用例1
7
解释：每次都-1，共7次

输入用例2
1000
输出用例2
2
解释：交换1和最后一个0，然后-1，共2次
```

>点评：
>
>-   这题目描述写的，真的是，说了两个操作都不写明白哪两个操作，哎😅，还得从用例来看。
>-   然后就是这个`10^100000`的数字真是吓到我了，一开始我还以为是`100000`呢，后面仔细看看，原来是`1000000....(共100000个0)`，一开始我用`cin >> int`，然后发现不太行。不过仔细想想，用`string`的话，其实就是最长`100000`位而已，跟力扣的最大一般差不多，
>-   题目倒是挺简单的，就是题目描述咋咋呼呼的。

解答如下：

```
显然从左到右遍历，然后最简单的方法就是，把左边的交换到最右边，然后减到0
```

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int solution(string s){
    long long res = 0;
    for(int i = 0; i < s.size(); ++i){
        if(s[i] != '0'){
            res += 
                static_cast<long long>(
            		i!=s.size()-1 // 最后一位不需要交换
                	+s[i]-'0' //
            	);
        }
    }
    return res;
}
int main(){
    string s;
    cin>>s;
    auto ret = solution(s);
    cout << ret << endl;
}

```

## 题目2

```
一行中右N(<=100000)个盒子，每个盒子能放一个球，现在进行M(<=100000)个操作，一共有三种类型
1. L 表示找到最左边的一个空盒子放球
2. R 表示找到最右边的一个空盒子放球
3. 数字表示从第 K(1<=K<=N) 个盒子把球拿出来（保证里面有球）
最后输出盒子的状态，0表示没有球，1表示有球

第一行输入N和M
下面M行输入M个操作
10 10
L
L
2
R
R
9
L
R
R
9
输出用例1
1100000101
```

>   点评：
>
>   -   一开始我用的$O(N^2)$复杂度糊弄的，然后后面一直追问我这个能不能更加简单，然后我说了用队列，用`set`等等，反正都没糊弄出来简单的。然后说全都用`set`，这样时间复杂度都是$O(\log N)$，但是反正最后应该是看我实在是答不出了，就又加了一个第五题，也有可能是我没开摄像头的原因。
>   -   有没有懂哥教教我怎么实现$O(N)$复杂度的

代码如下，但是$O(N^2)$复杂度的：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n = 0, m = 0;
    cin >> n >> m;
    vector<bool> box(n, false);
    int left = 0, right = n-1;
    for(int i = 0; i < m; ++i){
        string s;
        cin >> s;
        
        if(s == "L"){
            while(box[left] and left <= right){
                ++left;
            }
            if(left < right) box[left++] = true;
        }else if(s == "R"){
            while(box[right] and left <= right){
                --right;
            }
            if(left < right) box[right--] = true;
        }else {
            int num = stoi(s) - 1;
            if(num < left) left = num;
            else if(num > right) right = num;
            box[num] = false;
        }
    }
    return 0;
}
```

## 题目3

```
有一个大于等于0的数字N，其最大值为10^100000，现定义一个操作：如果某个数字它跟相邻的数字奇偶性不一样，则可以交换它们的位置，该操作可以重复无数次，输出经过若干次后得到的最小数。

输入用例1
0709
输出用例1
0079
解释：7和0奇偶不一样，交换位置

输入用例2
246432
输出用例2
234642
解释：3和464奇偶不一样，可以交换3次后得到第一个2后面
```

>   点评：
>
>   -   题目倒是挺简单的，一开始有点紧张了，想了好久好久这道题，甚至都打算放弃了的，但是不过最后还是做出来了

解答如下：

```
首先，奇数自己内部最后肯定是有序，偶数同样。所以，先提取奇偶数数组。然后使用归并排序的方式，根据小大顺序放奇偶数到结束数组里面。
```

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

string solution(string& number){
    int n = number.size();
    string ji,ou;
    for(auto ch:number){
        if((static_cast<int>(ch-'0') & 0x1) == 0){
            ou += ch;
        }else {
            ji += ch;
        }
    }
    string ans;
    int i = 0, j = 0;
    for(; i < ji.size() and j < ou.size();){
        if(ji[i] < ou[j]) ans += ji[i++];
        else ans += ou[j++];
    }
    if(i < ji.size()) ans += ji.substr(i);
    else(j < ou.size()) ans += ou.substr(j);
    return ans;
}

int main(){
    string number;
    cin >> number;
    auto ret = solution(number);
    cout << ret << endl;
    return 0;
}
```

## 题目4

```
有两个长度为N(<=100000)的数组A和B，其中A数组包括1到2N的所有奇数，B数组包括1到2N的所有偶数。
现定义一个操作，任意选择数组A和B，然后选定下标i，交换下标i和i+1的这两个数
求最少的操作次数让A数组的字典序小于B数组的字典序。
数组A的字典序小于数组B的字典序定义：可以简单当字符串来比较，比如：
1,2,3<2,2,3 1,2,3<1,3,3 1,2,3<2,0,0

输入用例1
2
3 1
4 2
输出用例1
0
解释：已经满足条件，不需要操作

输入用例2
3
5 3 1
2 4 6
输出用例2
2
解释：把1挪到最前面，或者把6挪到最前面

输入用例3
5
7 5 9 1 3
2 4 6 10 8
输出用例3
3
解释：把5挪到最前面，然后把6挪到最前面
```

>   点评：这道题目还算简单，估计也就mid难度吧，但是确实是一看比较难

解答如下：

```
对于任何两个数列
7 5 9 1 3
2 4 6 10 8
最简单的应该是做如下判断（i是第一个数列下标，j是第二个数列下标）
for i = 1...n:
	for j = 1...n:
		if(n1[i] < n2[j]):
			ans = min(ans, i+j)
现在时间复杂度是n^2，显然不ok，那么如何减少呢？

对于 j 遍历到6的时候，如果说，我们想把6放到最前面，那么需要找 1 3 5 这几个谁放到最前面是最少操作步骤的，显然是5，所以6对应的操作步应该是 2+1=3 把6移到最前面，把5移到最前面。

那么，有没有一个什么东西可以来记录一下这个呢，动态规划恰恰是干这个的。

假如我们维持着一个数组dp[k]，表示对于 k(偶数) 来说，小于k的奇数移动到最前面所需要的操作最少是多少。

问题又来了，这样的空间复杂度为O(2N)，怎么变小一点呢？

我们可以直到，对于一个偶数 K 来说，它在偶数中的序号其实是 K/2 - 1，同样，对于几个奇数 J 来说，在奇数中的序号是 J/2 那么对于同样的序号 J/2 == K/2-1 时，这是偶数是大于奇数的，也大于所有小于 J/2 的奇数，所以可以减小一点数组开销。

注意，下面奇偶数的序号统称序号，记住 偶数序号为 N 时，小于这个偶数的奇数序号是： [0, N]即可

现在问题回来了，怎么生成这个dp数组呢？分两步走，一：生成奇数数组，序号对移动次数的映射。二，遍历这个映射数组，就可以得到序号对最小移动次数序号的映射了（对于序号N来说，小于等于N的最小移动次数的序号是多少）。
```

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int solution(vector<int>& nums1, vector<int>& nums2){
    int n = nums1.size();
    vector<int> xu_to_moveTimes(n); // 序号 -> 移动次数
    vector<int> xu_to_minMoveTimesXu(n); // 序号 -> 最小移动次数的序号
    for(int i = 0; i < n; ++i){
        xu_to_moveTimes[nums1[i] / 2] = i;  // 奇数的序号就是 N/2
    }
	xu_to_minMoveTimesXu[0] = 0;
    for(int i = 1; i < n; ++i){
        int pre = xu_to_minMoveTimesXu[i-1];
        xu_to_minMoveTimesXu[i] = map[pre] > map[i] ? i : pre;
    }
    
    int ans = 100000;
    for(int i = 0; i < n; ++i){
        int xu = nums2[i] / 2 - 1; // 偶数的序号就是 N/2 - 1
        ans = min(
            		ans,  // 检测所有的偶数 
            		i     // 当前偶数移动到最前面需要的次数，就等于下标
            		+ xu_to_moveTimes[
                        xu_to_minMoveTimesXu[xu]  // 当前序号对应的最小移动次数序号
                                     ] // 获取最小移动次数序号对应的移动次数。
            	);
    }
    return ans;
}
```

## 题目5

```
数组里有N(<=100000)个数，现从数组里面删除一个连续子区间，要求剩下数全都不一样，问最小的连续区间长度。

输入用例1
5
1 2 3 2 3
输出用例1
2

输入用例2
1 2 3 3 2 1
输出用例2
3
```

>   点评：这是额外加的一道题目，所以当时也是很紧张，不过之前在力扣刷到过一个类似解法的题目，也很快想到解法了

解答如下：

```
使用滑动窗口+哈希的方式，力扣 HOT100 滑动窗口中有一个很像的题目了，这道题目只讲了思路，没具体写
```

代码如下（不完整代码）：

```cpp
int solution(vector<int>& vec){
    unordered_map<int, int> map;
    int greater_1_number = 0;  // 维持着大于1的数字个数
    for(auto v:vec){
        if(++map[v] > 1) ++greater_1_number;
    }
	
    for(int left = 0, right = 0; left < vec.size(); ++left){
        while(right < vec.size()){
            --map[vec[right]];
            if(map[vec[right]] == 1){
				// 说明大于1的数字个数减少一个了
				if(--greater_1_number == 0){
                    // 说明已经找到一个了
                    ans = min(ans, right - left);
                    break;
                }
            }
        }
		if(++map[vec[left]] == 2){
			// 说明又增多一个大于1的数字了，注意不要写 >1 否则会多次判断的，同样，前面也不要写 <2必须写 == 1
            ++greater_1_number;
        }
    }
}
```



# 反问环节

1.   微信安全团队主要的业务是什么

答：针对微信的黑灰产，涉及各种各样的岗位，开发的话负责开发安全后台的一些接口等等。

2.   主要用到的技术栈有哪些？

答：`Linux`操作系统，网络协议，业务中会用到的数据库，代码主要用`C++`

3.   之后学习方向上有什么推荐？

答：对于底层的知识欠缺

4.   实习可以转正吗？

答：可以，转正名额看具体的，不能保证一定能转正

5.   实习生的培养流程

答：实际参与到工作中，看看一些业务怎么解决，有文档等等，后面会慢慢进行简单业务的需求开发，然后再慢慢接触到更多的业务。

6.   整个流程有没有导师一对一或者一对多指导吗？

答：有一对一的导师的





















































































