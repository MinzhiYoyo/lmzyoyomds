---
title: 数据结构——串 KMP算法
date: 2022-05-16 12:25:41.0
updated: 2023-04-04 17:40:28.208
url: /archives/数据结构串kmp算法
categories: 
- 考研数据结构
tags: 
- 考研
- 数据结构
- 字符串
- KMP
---



# 字符串

## 1、字符串存储

## 2、字符串的模式匹配

&emsp;模式匹配是指，在主串中寻找模式串的位置。

- 简单模式匹配

  > 依次匹配，如果失配，就后移一位

- KMP模式匹配

  > 依次匹配，如果失配，根据`next数组`后移

## 3、KMP算法

&emsp;***假设所有下标都是从1开始***

### 基本概念

- 前缀集合：假设字符串为`p`，$\{ p_0,\quad p_0p_1, \quad... \quad,\quad p_0p_1...p_{n-1}  \}$
- 后缀集合：假设字符串为`p`，$\{ p_1,\quad p_1p_2, \quad... \quad,\quad p_1p_2...p_{n}  \}$
- 最长匹配长度：前缀集合与后缀结合中，最长相等元素的长度。
- 注意：**前**缀集合**不包含**$p_n$，**后**缀集合中**不包含**$p_0$，如果字串只有一个字符，那么前缀集合和后缀集合都为**空**。

### KMP算法基本

&emsp;假设我们已经有了`next`数组（下面会介绍`next`数组求解），假如在主串(`S`)下标为`i`，模式串(`P`)下标为`j`的位置失配了。

&emsp;暴力算法中，我们将会把`i`和`j`都回溯了，`i`回溯`j`个，`j`回溯到1。KMP算法中，我们让`i`不进行回溯，仅仅只回溯`j`。那么，`j`应该如何回溯呢?

&emsp;首先，这里只需要考虑模式串，next数组含义就是，在位置`j`前面有`next[j]-1`个字符组成的字符串与从位置1开始往后的`next[j]-1`个字符组成的字符串是相等的。

&emsp;然后，因为主串与模式串在位置j前面的字符串完全相等。我们就只需要把模式串回溯到不相等的位置，最开始不相等的位置，应该是第`next[j]`个位置。

&emsp;解释，因为我们知道$P_1...P_{next[j]-1}$与$P_{j-next[j]}...P_{j-1}$是相等的，所以只需要从主串当前位置与模式串`P[next[j]]`开始继续比较即可。也就是，i不变，`j = next[j]`

### `Next`数组求解

&emsp;定义：模式串为`p`（下标从1开始），`next[i]`：`p[1]~p[i-1]`组成的**子串**的最长匹配长度**加**1。

&emsp;特殊地，`next[1] = 0`。`next`数组只与模式串有关系，与主串无关。

&emsp;`next[i]`的值与`p[i]`**无关**，只与`p[i]`**前面的值**有关。
$$
next[j] = \begin{cases}
0 & j=1\\
max \{ k \quad|\quad 1<k<j 且 'p_1...p_{k-1}'='p_{j-k+1}...p_{j-1}'  \} & 当此结合不为空时\\
1 & 其他情况
\end{cases}
$$
&emsp;上述公式看不懂，问题不大，我也没看懂。

- 人为求解

  > 人为求解的话，根据定义来即可，一步一步算

- 代码求解

  > 比较复杂

&emsp;***附上代码***

``` cpp
// 模式串为p
int next[p.size] = {0};
next[1] = 0;
for(int i = 2 ; i < p.size; i++){
    int j = next[i-1];
    while(true){
        if(j==0 || p[j] == p[i-1]){
            next[i] = j;
            break;
		}else {
            j = next[j];
        }
    }
}
```



### KMP算法优化，`NextVal`数组求解

&emsp;前面提到`next[j]`值与`p[j]`无关，只与前前面的字符串有关。如果在`j`失配，也就是`p[j]!=s[i]`的话，那么下一个`j`回溯到`next[j]`的位置。如果此时`p[next[j]]!=s[i]`的话，那么还得继续回溯到`p[next[next[j]]]`，不如我们在构建`next`数组就把这种情况规避掉。因此，有了下列优化算法。

&emsp;其他情况与上述`next`数组构造一样，不同的是，如果`p[j]==p[next[j]]`，就把上面代码改为如下：

``` cpp
...
        if(j==0 || p[j] == p[i-1]){
            if(p[j] != p[i]) next[i] = j;
            else next[i] = next[j];
            break;
		}else {
            j = next[j];
        }
...
```

&emsp;如何在考试中人为求解呢？

答：我的建议是，先求出`next`数组，然后在`next`数组的基础上，再看。如果`p[j]==p[next[j]]`，就修正`nextval[j]=nextval[next[j]]`。否则不变。因为是从前往后的，所以我们在`next`和已修正`nextval`的基础上，构造出`nextval[j]`。

&emsp;如题所示，`"ababaaababaa"`的`nextval`数组应该是什么样的？

|    下标    |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |  12  |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **模式串** |  a   |  b   |  a   |  b   |  a   |  a   |  a   |  b   |  a   |  b   |  a   |  a   |
|   `next`   |  0   |  1   |  1   |  2   |  3   |  4   |  2   |  2   |  3   |  4   |  5   |  4   |
| `nextval`  |  0   |  1   |  0   |  1   |  0   |  4   |  2   |  1   |  0   |  1   |  0   |  4   |